---
timezone: UTC+8
---

# D

**GitHub ID:** t19971104

**Telegram:** @13817399983

## Self-introduction

KEEP LEARNING

## Notes

<!-- Content_START -->
# 2025-10-19
<!-- DAILY_CHECKIN_2025-10-19_START -->
### **🧠 A2A架构：代理的协作语言**

A2A协议是一种开放标准，旨在为不同的AI代理提供一种通用“语言”，使它们能够相互发现、通信和协作，无论其背后的开发平台、框架或供应商如何

。其核心设计哲学是​**​赋能代理自主性​**​、​**​基于现有标准构建​**​、​**​默认安全​**​、​**​支持长时运行任务​**​以及​**​模式不可知​**​

。

**核心组件与工作流程**

A2A架构的精妙之处在于其定义清晰的核心组件和交互流程。

| ​​核心组件​​ | ​​核心职责​​ | ​​关键要点​​ |
| --- | --- | --- |
| ​​代理卡​​ | 代理的“数字身份证”，是一个JSON格式的元数据文件，通常存放在 /.well-known/agent.json路径下。它声明了代理的能力、通信端点、所需认证协议及版本兼容性等信息。 | 机器可读，支持动态更新，是实现能力发现的基础。 |
| ​​任务对象​​ | 代理间协作的基本工作单元。它包含唯一任务ID、状态（如进行中、需输入、已完成）、任务过程中交换的消息历史以及最终的输出​​产物​​。 | 一个任务可以包含多种形式的内容（文本、图像、音频等）。 |
| ​​通信模型​​ | 采用​​客户端代理-远程代理​​模型。客户端代理发起任务，远程代理执行任务。交互通过​​JSON-RPC 2.0​​ over HTTP的消息格式进行，并利用​​服务器发送事件​​实现实时更新。 | 代理间不共享内部状态或记忆，通过结构化消息进行协作，保持了解耦和安全性。 |

代理间协作的基本工作流程可以概括为：​**​发现​**​ -> ​**​任务发送与执行​**​ -> ​**​异步通信与更新​**​。首先，客户端代理通过查询代理卡来发现具备所需能力的远程代理

。随后，客户端代理会创建一个任务对象，并将其发送至远程代理的端点。远程代理开始处理任务，而客户端代理则无需等待，可以继续处理其他工作

。对于长时运行的任务，远程代理可以通过SSE向客户端代理持续发送状态更新，直到任务完成或需要额外输入

。

**安全与信任模型**

A2A将安全视为首要原则。它通常依赖​**​传输层安全​**​（HTTPS）并结合​**​OAuth、OIDC​**​等应用级认证方案（在代理卡中声明）来确保通信安全并验证参与方身份

。这种设计使得A2A能够满足企业级应用的安全需求。

### **💳 AP2协议：代理经济的信任基石**

AP2协议是构建在A2A等代理通信协议之上的支付扩展层，专门用于解决在AI代理代表用户进行交易时产生的​**​授权、身份验证和责任归属​**​等核心挑战

。

**为何需要AP2？**

在传统电子商务中，支付由用户通过受信任的界面（如商家网站）直接发起。而当AI代理自主操作时，现有支付系统面临巨大挑战：如何验证代理确实获得了用户的授权？如何防止代理因“幻觉”或错误进行不当购买？交易出现问题时责任应由谁承担？AP2协议通过引入​**​可验证数字凭证​**​这一核心机制，为这些问题提供了清晰的答案

。

**AP2的核心机制与工作流程**

AP2协议的关键创新在于其“指令”系统，这是一种防篡改、加密签名的数字合约，旨在确保持久且明确的责任划分

。

| ​​指令类型​​ | ​​适用场景​​ | ​​核心内容​​ |
| --- | --- | --- |
| ​​购物车指令​​ | 用户在场场景。当用户明确指示代理购买特定商品时，需要签署此指令。它包含了最终确定的商品、价格、支付方式等不可变信息，是立即执行的购买授权。 | 用户对​​最终确定的交易​​进行授权。 |
| ​​意向指令​​ | 用户不在场场景。用户预先设定条件（如价格上限、商品特征），代理在条件满足时自动购买。它授权代理在特定条件下代表用户行事。 | 用户授予代理在​​特定条件下​​进行购买的权限。 |

其工作流程涉及多个角色：用户及其代理、商家的代理或端点、以及凭证提供者（如数字钱包或银行）。AP2通过角色分离确保安全，例如，处理支付的代理可能无法访问完整的支付凭证信息

。这些由用户加密签名的指令构成了一个不可否认的审计追踪链条，明确记录了“谁在何时授权了什么”，从而为整个支付生态系统（商家、支付处理商、发卡行）提供了清晰的责任界定依据

。

### **🛠️ 实践应用：从理论到实现**

了解了A2A和AP2的原理后，我们来看看如何将它们结合起来，实现一个完整的、具备商务能力的代理。

1.  ​**​代理注册与能力声明​**​
    
    首先，你需要让你的代理在网络中被感知。这通过创建和发布其​**​代理卡​**​来实现。你需要编写一个标准的`agent.json`文件，详细说明你的代理具备的所有能力。例如，一个商务代理的能力可能包括`productSearch`（产品搜索）、`priceNegotiation`（价格协商）和`checkout`（结算）
    
    。之后，通过DNS或注册中心将此代理卡公之于众，以便其他代理能发现你
    
    。
    
2.  ​**​代理发现与任务发起​**​
    
    当你的代理需要协助时（例如，用户请求“为我预订下一次出差的航班和酒店”），它会扮演客户端代理的角色。它可以通过查询注册中心或直接查询特定域名的代理卡，来寻找具备相应能力的远程代理（例如，专业的旅行预订代理）
    
    。找到后，你的代理会创建一个任务对象，其中包含用户的请求详情，并通过JSON-RPC调用将其发送给旅行代理
    
    。
    
3.  ​**​协作与支付集成​**​
    
    旅行代理接收任务后开始工作，它可能会进一步与航空公司代理、酒店代理等进行A2A通信，以收集信息并完成预订
    
    。当行程方案确定后，需要支付时，AP2协议便开始发挥作用。你的代理会指导用户签署相应的​**​购物车指令​**​（用于立即支付）或​**​意向指令​**​（用于预授权代理在特定条件下支付）
    
    。最终，支付指令会由用户信任的凭证提供者（如其数字钱包）安全地执行。
    

### **💎 总结与展望**

A2A架构与AP2协议共同构成了未来智能代理协同网络的坚实基础。A2A解决了代理“如何交谈”的问题，而AP2则解决了代理“如何安全交易”的问题。它们的结合，使得构建能够自主处理复杂、跨领域、涉及经济活动的业务流程成为可能，真正开启了由智能代理驱动的自动化新时代

。

希望这份系统的介绍能帮助你掌握这些关键技术。如果你对某个特定部分（例如代理卡JSON的具体结构，或AP2指令的加密签名细节）有进一步的兴趣，我们可以进行更深入的探讨。
<!-- DAILY_CHECKIN_2025-10-19_END -->

# 2025-10-16
<!-- DAILY_CHECKIN_2025-10-16_START -->

**Module 1: The Trust Foundation — ERC-8004 Identity & Reputation Layer** 的标准、设计原理、实际动手环节及生态意义。  
分为 5 个部分：**概念框架 / 标准解析 / 技术组成 / 实践环节 / 延伸阅读与思考。**

* * *

## 一、概念框架：The Trust Foundation

**核心主题：建立可信身份与声誉层，为 Agent 经济提供信任基础。**

> 在 Web3 Agent 生态中，身份（Identity）与声誉（Reputation）是智能体之间互动、协作与交易的信任基石。  
> ERC-8004 的目标是为 “智能体（Agent）” 提供可验证、可追踪、可组合的身份与信誉体系。

**关键词：**

-   **On-chain Identity:** 区块链原生身份标识（类似 DID）。
    
-   **Reputation Layer:** 声誉记录与评分机制。
    
-   **Verification Layer:** 认证、证明与可验证凭证。
    
-   **Composable Trust:** 信任是模块化、可移植的（信任可以从一个协议迁移到另一个协议）。
    

* * *

## 二、标准解析：ERC-8004 核心结构

ERC-8004 定义了 **三个主要 Registry（注册表）**，共同构成 Identity-Reputation-Verification 三层信任结构。

### Identity Registry — 身份注册表

-   功能：为每个实体（人 / 智能体 / 组织）创建一个唯一链上身份 ID。
    
-   支持：DID, ENS, Soulbound Token（SBT）等扩展形式。
    
-   通常存储：
    
    -   `identityId`
        
    -   `ownerAddress`
        
    -   `metadataURI`
        
    -   `linkedAccounts`（多链或跨协议账户）
        

📌 _重点概念：_  
可组合身份（Composable Identity）—— 一个身份可以关联多个钱包、协议和平台。

* * *

### Reputation Registry — 声誉注册表

-   功能：存储、更新并公开一个身份的声誉数据。
    
-   声誉可来源于：
    
    -   On-chain 数据（交易记录、参与行为）
        
    -   Off-chain 数据（平台反馈、审计评分）
        
    -   Verified Attestations（可验证声明）
        
-   声誉指标示例：
    
    -   贡献度（Contribution Score）
        
    -   可信度（Trust Score）
        
    -   稳定性（Activity/Consistency Score）
        

_重点机制：_

-   声誉是动态的（可更新）
    
-   声誉是可验证的（带签名来源）
    
-   声誉是可继承的（跨平台复用）
    

* * *

### Verification Registry — 验证注册表

-   功能：存储身份或声誉的验证凭证（VC / Attestation）。
    
-   常用于：
    
    -   实名验证（KYC / KYB）
        
    -   信誉背书（Reputation Endorsement）
        
    -   技能认证（Skill Badge）
        
-   实现可采用：
    
    -   EIP-712 typed data
        
    -   AttestationStation (EAS)
        
    -   W3C Verifiable Credentials
        

_重点机制：_  
通过链上 attestation 机制实现“去中心化的信任背书”。

* * *

## 三、技术组成：实现逻辑与交互模型

**主要合约模块：**

```solidity
interface IERC8004IdentityRegistry { ... }
interface IERC8004ReputationRegistry { ... }
interface IERC8004VerificationRegistry { ... }
```

**数据流逻辑：**

```
Agent 创建身份 → Identity Registry 注册 → 
行为与交互产生声誉数据 → Reputation Registry 更新 → 
验证方提供签名证明 → Verification Registry 存档
```

**合约间交互图：**

```
 ┌─────────────────────────┐
 │  Identity Registry      │  ← 创建身份
 └─────────────┬───────────┘
               │
               ▼
 ┌─────────────────────────┐
 │  Reputation Registry    │  ← 收集/存储信誉
 └─────────────┬───────────┘
               │
               ▼
 ┌─────────────────────────┐
 │  Verification Registry  │  ← 验证/背书/证明
 └─────────────────────────┘
```

* * *

## 四、实践环节（Hands-on）

### Step 1: 创建一个链上身份

使用 Solidity 实现一个简单的 ERC-8004 Identity Registry 合约：

```solidity
contract SimpleIdentityRegistry {
    struct Identity {
        address owner;
        string metadataURI;
    }

    mapping(address => Identity) public identities;

    function registerIdentity(string calldata uri) external {
        require(identities[msg.sender].owner == address(0), "Already registered");
        identities[msg.sender] = Identity(msg.sender, uri);
    }

    function getIdentity(address user) external view returns (Identity memory) {
        return identities[user];
    }
}
```

### Step 2: 实现一个简单的 off-chain reputation feedback system

可以使用 **Next.js + Supabase / Firebase** 搭建一个声誉反馈后端：

```js
// Example: submit feedback
await db.insert({
  from: userAddress,
  to: agentAddress,
  score: 4.5,
  comment: "Very reliable response quality."
});
```

然后使用签名（EIP-712）将反馈上链更新 Reputation Registry。

* * *

### Step 3: Agent 与身份绑定

为你的 AI Agent / Bot 创建一个链上身份：

-   通过 `registerIdentity()` 上链；
    
-   在 agent 配置文件中（如 YAML / JSON）绑定该链上地址；
    
-   Agent 交互日志中引用该 identityId。
    

* * *

## 五、延伸阅读与思考

| 来源 | 内容摘要 | 重点 |
| --- | --- | --- |
| EIP-8004 Official Standard | 标准定义与接口设计 | 核心结构、接口说明 |
| Ethereum Magicians Discussion | 标准提案讨论 | 社区对身份模型的反馈 |
| Quill Audits Analysis | 审计角度解读 | 安全性与合约可扩展性 |
| Medium - ERC-8004 Story & Next Steps | 背后理念与应用方向 | 从 DID → Agent Identity 的演化 |
| Vistara Apps Example | 开源实现案例 | Registry 与 UI 结合 |
| HashKey Capital - ERC-8004 & Agent Economy | 投资与生态分析 | 信任层对 Agent 经济的价值 |

* * *

## 六、总结与未来趋势

| 维度 | 未来演进方向 |
| --- | --- |
| 技术 | 与 ERC-6551 (Token Bound Account) / ERC-780 (Claim Registry) / EAS 集成 |
| 经济 | 声誉作为资产，可抵押、租赁、交易 |
| 社会 | 实现去中心化信用体系、社区治理信任度模型 |
| AI Agent | 每个智能体拥有链上身份与声誉，支持自治与协作 |

* * *
<!-- DAILY_CHECKIN_2025-10-16_END -->
<!-- Content_END -->
