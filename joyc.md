---
timezone: UTC+9
---

# hython

**GitHub ID:** joyc

**Telegram:** @hython

## Self-introduction

Web3 Product PM

## Notes
<!-- Content_START -->
# 2025-10-19
<!-- DAILY_CHECKIN_2025-10-19_START -->
AP2（Agent Payments Protocol）  
基于 Agent2Agent（A2A）、Model Context Protocol（MCP），采用 W3C 可验证凭证（VCs）。  
核心机制：签名授权指令 Mandate（如 CartMandate、IntentMandate、PaymentMandate），确保意图可追溯、不可抵赖。

### 整体架构理解：A2A + AP2 的协作关系

-   **A2A协议**：为AI Agent之间的多方通信、任务流与身份发现/鉴权提供基础，是Agent协作的“底层安全总线”。
    
-   **AP2协议**：在A2A之上扩展，专注Agent驱动的支付场景，特别是合规律且可验证的资金操作，实现了可信授权、非否认性、强安全验证和合规责任追溯（尤其适配稳定币结算、RWA托管场景）。
    

在稳定币平台或多智能体协作式金融产品中，涉及多角色（如法币出入金服务商、合规审计方、托管机构、KYC/AML风控Agent、链上多签Agent等）的协同与消息互通。A2A协议为此类复杂金融场景提供了高扩展性和安全的Agent间通信接口。

**典型场景需求包括：**

-   链上/链下信息交互（如铸造、销毁、质押、法币清算等通知）
    
-   合规风控/审计协同（如多角色审批、自动风控触发、合规报告推送）
    
-   多签/Manager协同（链上多签操作任务的流程化与任务回溯）
    
-   数据结构化、操作流程自动化（如资产证明、支付授权等）  
      
      
    AP2设计核心与稳定币场景价值
    

1.  **角色与责任分明**
    
    -   区分User/Shopping Agent/支付信息Provider/Merchant端/支付处理/链上发行方等，让金融风险、合规以及安全审核职责明确分布，避免单点失效和“黑盒”操作。
        
2.  **基于可验证凭证(VC)的强授权**
    
    -   AP2以VC形式（如Intent Mandate和Cart Mandate），把用户的授权、交易详情通过加密签名方式固化成数字合同。
        
    -   这些VC可跨Agent、多方流转、被独立验证，实现资金链追溯与合规监管下的不可抵赖性。
        
    -   在无人场景（Human-not-present）中，设计TTL、有条件授权、意图验证与溯源，确保合规（如监管审核RWA资产清算任务）。
        
3.  **全流程多方签名/认证链/异步驱动机制**
    
    -   每笔资金流、资产移转、结算等稳定币关键步骤都可“流程建模”，重放和审计任务流、状态流与交易签名链。
        
    -   支持链下授权引发链上合规多签，适合复杂的RWA发行、法币入金、BTC/ecny/JPYC跨链场景。
        
4.  **抗攻击与安全保障机制**
    
    -   防止Mandate伪造/篡改（ECDSA签名+PKI+硬件密钥），任务流具备审核点，支持强认证（多因子/生物识别/TPM硬件加密）。
        
    -   明确责任归属（如异常转账可追溯到Agent、User、第三方合规商户），利于后续金融博弈或合规处置。
        
    -   可灵活对接零知识证明、MPC等未来抗量子技术或多方联署要求。
        

###   
A2A协议机制对稳定币场景的价值

### 1\. 任务管理与状态流转

-   **任务（Task）**是A2A下操作的最小单元，涵盖唯一ID、状态机（如待审批、执行中、已完成、异常、需补充认证等状态）
    
-   支持长流程、多角色审批和异步通知（推送Webhook），保证复杂操作的流程可追踪、状态一致
    

### 2\. 灵活的数据与文件传递

-   支持传递文本、文件、结构化数据（可用于链上事务凭证、审计报告、合规资料等多模态内容）
    
-   接入JSON-RPC/gRPC/REST等多协议，完全适配后端金融基础设施多样性
    

### 3\. 安全与认证

-   支持多重认证机制（API Key/OAuth/mTLS），可针对不同角色或操作灵活配置
    
-   任务中如需链下外部授权（如银行KYC认证、托管方人脸核查等），可临时进入“auth-required”状态、要求补充凭证
    

### 4\. Agent发现与多方互信

-   通过**Agent Card**宣告各角色Agent能力（如稳定币铸造Agent、多签Agent、合规风控Agent）
    
-   Agent能力和接口自动发现，适合多机构分布式部署与流程解耦
    

### 5\. 文件、数据及链上事件的流式推送

-   复杂链上事件（如多签交易确认、资金流向变更）可通过**Server-Sent Events**或Webhook主动推送，提高多方同步效率
    
-   支持操作回滚与异常流转，实现任务流程合规可审计
    

  
典型实现路径举例

举例：链下法币进场→KYC/AML风控Agent→多签资产托管Agent（链上多签）→稳定币发行

-   各Agent通过A2A协议任务与消息流，将每一个流程节点标准化建模，并通过事件驱动同步到所有利益相关方
    
-   发生如风控、合规未通过等事件时，自动变更任务状态，驱动后续审批/补充认证/拒绝处理流程
    

**核心交互流程：**

1.  User提交法币入金请求→和法币接口Agent建立A2A通信，生成唯一Task
    
2.  KYC/AML Agent自动接收任务，处理完毕后通过A2A回传审核结论（同步/异步均可）
    
3.  多签Agent检测到状态变化后，发起链上资产托管签名流程
    
4.  稳定币铸造Agent收到链上事件后，完成发行/通知归档/生成报告
    
5.  全程状态与所有参与方保持同步，异常节点可追溯、可审计
    

  
结构化要点总结

-   **高弹性任务流：** 支持异步、人机协作与长流程（金融审批特征）
    
-   **多模态交互：** 兼容文本、文件、结构化数据，直达链上/链下
    
-   **协议兼容性强：** 支持JSON-RPC/gRPC/HTTP REST三种主流通信协议，适合多后端对接
    
-   **安全合规：** 全程强认证，灵活安全策略适应金融合规
    
-   **Agent能力声明与发现机制：** 支持大型RWA/稳定币系统的多机构协作与权限解耦
    
-   **推送/流式事件通道：** 支持金融事件驱动型流程，提升应变与协同效率
<!-- DAILY_CHECKIN_2025-10-19_END -->

# 2025-10-18
<!-- DAILY_CHECKIN_2025-10-18_START -->

# **A2A（Agent2Agent）协议学习笔记**

A2A是一个开放标准，用于让不同厂商、不同框架、不同组织的AI代理以统一语言协作。它避免将代理“包装成工具”的低效做法，直接以代理身份进行多轮、协商、委派等复杂互动，从而打破孤岛、提升互操作与扩展性。

核心收益包括：基于HTTPS的安全协作与不透明执行保护内部逻辑；跨生态互操作；保持代理自治与能力；降低集成复杂度；原生支持长时任务与SSE流式与异步。设计原则强调简洁（复用HTTP、JSON‑RPC、SSE）、企业级能力（认证、授权、隐私、追踪、监控）、异步与多模态、以及不暴露内在实现的协作。

在技术栈位置上，A2A与MCP、ADK分工明确：MCP侧重把模型连接到数据与外部资源（工具通常无状态、功能固定）；A2A侧重让代理以原生方式协作与多轮交互（如谈判与澄清）；ADK是谷歌开源的代理开发工具包，而A2A独立于框架，面向跨组织通信。

请求生命周期分四步：代理发现（获取Agent Card）、认证（如OpenID Connect获取JWT）、发送消息sendMessage（创建任务并返回响应）、以及sendMessageStream（通过SSE流式推送任务状态与产物，支持长时操作）。

\# A2A（Agent2Agent）协议深度学习笔记

A2A（Agent2Agent）协议是一个面向未来 AI 协作生态的开放标准，旨在解决“异构 AI 代理如何高效、安全、可扩展地协同工作”这一核心问题。以下是对 A2A 协议的系统性整理与深度解读，涵盖其设计哲学、核心组件、技术栈与潜在价值。

A2A 的设计遵循五大核心原则 ：

1\. **Simplicity（简洁性）**

复用现有成熟标准（HTTP、JSON-RPC 2.0、SSE），降低学习与集成门槛。

2\. **Enterprise Readiness（企业就绪）**

从协议层原生支持认证、授权、审计、追踪等企业级需求。

3\. **Asynchronous First（异步优先）**

支持长时间运行任务、断连恢复、人类介入等现实场景。

4\. **Modality Agnostic（模态无关）**

不仅支持文本，还支持文件、结构化表单、富媒体等多模态数据交换。

5\. **Opaque Execution（黑盒执行）**

Agent 无需暴露内部状态或工具链，仅通过声明能力（Agent Card）和上下文交换实现协作。

\## 核心概念与组件

\### 1. **Agent Card（代理卡片）**

\- 是 Agent 的“能力名片”，用于\*\*服务发现\*\*。

\- 包含：名称、描述、支持的技能（Skills）、输入/输出格式、认证方式等元数据 。

\- 其他 Agent 可通过 Agent Card 判断是否能协作，无需了解其实现细节。

\### 2. **Task（任务）**

\- 是 A2A 中\*\*有状态的工作单元\*\*，具有唯一 ID 和明确定义的生命周期 。

\- 状态机包括`submitted` → `working` → `completed` / `failed` / `cancelled` 等 。

\- 支持多轮交互、长时间运行、进度追踪，是异步协作的基础抽象 。

\### 3. **Message / Part / Artifact**

\- **Message**：Agent 间通信的基本单位。

\- **Part**：Message 的组成部分，可包含文本、文件引用、结构化数据等。

\- **Artifact**：任务执行过程中产生的可持久化输出（如生成的报告、图像等）。

\## 通信架构与技术栈

A2A 采用分层设计，明确分离\*\*传输层\*\*与\*\*协议语义层\*\*：

| 层级 | 技术选型 | 说明 |

|------|--------|------|

| **传输层** | HTTP/HTTPS | 必须支持 TLS 加密，确保安全 |

| **消息格式** | JSON-RPC 2.0 | 所有请求/响应负载均采用此标准格式 |

| **流式通信** | Server-Sent Events (SSE) | 用于异步推送任务状态、中间结果等 |

\> 例如：一个 `sendMessage` 请求通过 HTTPS 发送 JSON-RPC 调用，响应可能是一个 SSE 流，其中每个 `data` 字段包含一个 JSON-RPC 响应 。

这种设计使得 A2A **兼容现有 Web 基础设施**，易于部署、监控和调试。

\-–

\## 安全与企业级支持

\- **认证与授权**：基于标准 Web 实践（如 OAuth2、API Key），在 HTTP 层处理 。

\- **隐私与合规**：通过最小化上下文共享、不强制内存/工具暴露，降低数据泄露风险。

\- **可观测性**：任务 ID 与状态机天然支持追踪、日志、审计 。

\## 生态价值与未来展望

采用 A2A 协议可带来显著优势 ：

\- **提升互操作性**：不同框架（LangChain、LlamaIndex、AutoGen 等）开发的 Agent 可无缝协作。

\- **降低集成复杂度**：告别点对点定制集成，转向“即插即用”。

\- **激发创新**：鼓励开发者专注构建垂直领域 Agent（如法律、医疗、金融），形成繁荣生态。

\- **面向未来**：协议设计具备扩展性，可适应多模态、具身智能等新范式。

\-–

**总结**：A2A 协议不仅是技术规范，更是一种\*\*协作范式\*\*的升级。它为 AI 代理从“单打独斗”走向“群体智能”提供了基础设施，有望成为下一代 AI 应用的“TCP/IP”。对于开发者而言，掌握 A2A 意味着站在 AI 协作生态的前沿。
<!-- DAILY_CHECKIN_2025-10-18_END -->

# 2025-10-17
<!-- DAILY_CHECKIN_2025-10-17_START -->


## 为什么需要设计三层注册：  
  
1\. 身份层（Identity Registry）——“我是谁？”

**目的：确立唯一、可验证的智能体身份。**

-   每个 Agent 必须在链上注册，获得唯一的 `AgentID`。
    
-   该 ID 与其域名（AgentDomain）和以太坊地址（AgentAddress）绑定。
    
-   所有注册信息公开透明，任何人都能解析并验证。
    
-   链下，智能体需要在 `/.well-known/agent-card.json` 处发布自己的「Agent Card」，描述能力、模型类型、验证方式等。
    

**意义**：  
身份层解决了最基础的「谁是谁」的问题——没有可信身份，后续的信誉与验证都无从谈起。它构建了去中心化的「身份命名系统」，类似于区块链世界的 DNS。

* * *

### 2\. 信誉层（Reputation Registry）——“我值不值得信任？”

**目的：建立可追踪的声誉系统。**

-   当客户端智能体（Client Agent）与服务端智能体（Server Agent）交互后，可以授权反馈。
    
-   合约不存储评分，而是仅生成一个「反馈授权事件（AuthFeedback）」。
    
-   真正的评分与评价数据存放在链下（例如 JSON 文件），可以由第三方信誉系统读取并计算综合分数。
    

**意义**：  
信誉层为智能体提供了社会性信任来源。它模拟人类社会中的“口碑”，为低风险、日常任务（如内容生成、信息查询）提供足够的信任基础，而不需要昂贵的链上验证。

* * *

### 3\. 验证层（Validation Registry）——“我能证明我做对了吗？”

**目的：在高风险场景下提供强验证。**

-   用于发起和记录验证请求（ValidationRequest / Response）。
    
-   支持两种验证模式：
    
    -   **加密经济验证（Crypto-Economic Validation）**：验证者（Validator）需质押一定资金，若验证错误将被惩罚（slashing）。
        
    -   **密码学验证（Cryptographic Validation）**：通过 TEE 可信执行环境、ZK 证明等方式提供可验证的执行结果。
        
-   适用于金融交易、智能合约审计、医疗或高价值任务等高风险场景。
    

**意义**：  
验证层是“硬信任”机制，用经济或密码学手段保证行为真实可靠。它防止恶意或错误的智能体执行关键任务。

* * *

### 为什么要“三层”？

因为不同任务的风险与成本不同，信任机制需要「分层而非统一」：

| 场景 | 所需信任强度 | 对应层级 | 示例 |
| --- | --- | --- | --- |
| 低风险（如生成文本） | 弱信任 | 信誉层 | “内容好不好”由反馈决定 |
| 中风险（如金融建模） | 中等信任 | 经济验证层 | 验证者重跑计算、质押保证 |
| 高风险（如医疗决策） | 强信任 | 密码学验证层 | 通过 TEE 或 ZK 证明执行正确性 |

**总的目标**：在「成本」与「信任」之间取得最优平衡。  
区块链不适合把一切都放在链上，ERC-8004 采用混合式架构：**只把最必要的信任锚点上链**，其余逻辑交给链下扩展系统处理。

* * *

> ERC-8004 的三层信任体系让 AI 智能体能在不同风险场景下自由选择信任级别，从“轻量级信誉”到“加密经济验证”，再到“硬件级密码证明”，既保持去中心化，又兼顾效率与安全。
<!-- DAILY_CHECKIN_2025-10-17_END -->

# 2025-10-15
<!-- DAILY_CHECKIN_2025-10-15_START -->



# **ERC-8004: Trustless Agents**

[https://eips.ethereum.org/EIPS/eip-8004](https://eips.ethereum.org/EIPS/eip-8004)

**背景：**  
ERC-8004 把“发现、口碑、验证”三件事标准化为三套轻量注册表，为开放的 agent 经济提供可组合的信任层，补上 MCP/A2A 没覆盖的“谁、能不能信、谁来背书”的空白。

### **为什么有用（给产品/架构的直观价值）**

-   **可组合**：评分/验证事件在链上可被任意合约消费，离链再做复杂聚合；适合做 agent 目录、排行、质检与保险等上层生态。
    
-   **跨协议桥接**：注册文件里统一挂 **A2A、MCP、ENS、DID、钱包** 等端点，让通信层（会话/指令）与信任层（发现/评价/验证）解耦。
    
-   **成本/灵活度**：把大对象放离链（IPFS/HTTP）+ 链上存最小必要索引/哈希，既省 gas 又保留审计轨迹。围绕“哪些字段需要链上可读”社区仍在讨论中。
    

### **核心机制**

-   **Identity Registry（身份）**：把每个 agent 铸造成一枚 **ERC-721**（带 URIStorage），tokenURI 指向注册文件（含名称、说明、端点清单如 A2A/MCP/ENS/DID、agent 钱包等）。可多链/多注册，天然可浏览与转移。
    
-   **Reputation Registry（声誉）**：任何客户端地址（人/agent）都可在 agent 许可下提交 **0–100 分**的反馈，含可选标签与离链 JSON（IPFS 优先，链上存摘要/索引以便组合）。读接口支持按 reviewer/标签聚合。撤回与附加回应也有事件。
    
-   **Validation Registry（验证）**：agent 主动向某个 **validator 合约**发起验证请求（请求数据放离链 + 哈希承诺），validator 回写 **0–100** 的响应值与证据 URI（可多次更新，支持软/硬终局）。聚合读取接口可按 validator/tag 汇总。
    

> 提案刻意把**支付**排除在标准之外，但示例建议把 x402 支付证明等作为离链反馈字段一并记录。

### **最小落地路径**

1.  **部署 IdentityRegistry**（每链单例）→ register() 铸出 agentId → 设置 tokenURI 指向注册 JSON，填上 A2A/MCP/钱包等端点与 supportedTrust。
    
2.  **接单时**，agent 用 **EIP-191/ ERC-1271** 签出 feedbackAuth，授权某客户端地址可写反馈。客户端调用 giveFeedback(...) 上链；需要时可 revokeFeedback(...) 或附加 appendResponse(...)。查询用 getSummary(...) / readAllFeedback(...)。
    
3.  **需要强信任时**，调用 validationRequest(...) 指定 validator；待对方 validationResponse(...) 回写评分与证据。汇总用 getValidationStatus(...) / getSummary(...)。
<!-- DAILY_CHECKIN_2025-10-15_END -->
<!-- Content_END -->
