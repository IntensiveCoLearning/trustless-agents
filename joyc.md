---
timezone: UTC+9
---

# hython

**GitHub ID:** joyc

**Telegram:** @hython

## Self-introduction

Web3 Product PM

## Notes
<!-- Content_START -->
# 2025-10-18
<!-- DAILY_CHECKIN_2025-10-18_START -->
# **A2A（Agent2Agent）协议学习笔记**

A2A是一个开放标准，用于让不同厂商、不同框架、不同组织的AI代理以统一语言协作。它避免将代理“包装成工具”的低效做法，直接以代理身份进行多轮、协商、委派等复杂互动，从而打破孤岛、提升互操作与扩展性。

核心收益包括：基于HTTPS的安全协作与不透明执行保护内部逻辑；跨生态互操作；保持代理自治与能力；降低集成复杂度；原生支持长时任务与SSE流式与异步。设计原则强调简洁（复用HTTP、JSON‑RPC、SSE）、企业级能力（认证、授权、隐私、追踪、监控）、异步与多模态、以及不暴露内在实现的协作。

在技术栈位置上，A2A与MCP、ADK分工明确：MCP侧重把模型连接到数据与外部资源（工具通常无状态、功能固定）；A2A侧重让代理以原生方式协作与多轮交互（如谈判与澄清）；ADK是谷歌开源的代理开发工具包，而A2A独立于框架，面向跨组织通信。

请求生命周期分四步：代理发现（获取Agent Card）、认证（如OpenID Connect获取JWT）、发送消息sendMessage（创建任务并返回响应）、以及sendMessageStream（通过SSE流式推送任务状态与产物，支持长时操作）。

\# A2A（Agent2Agent）协议深度学习笔记

A2A（Agent2Agent）协议是一个面向未来 AI 协作生态的开放标准，旨在解决“异构 AI 代理如何高效、安全、可扩展地协同工作”这一核心问题。以下是对 A2A 协议的系统性整理与深度解读，涵盖其设计哲学、核心组件、技术栈与潜在价值。

A2A 的设计遵循五大核心原则 ：

1\. **Simplicity（简洁性）**

复用现有成熟标准（HTTP、JSON-RPC 2.0、SSE），降低学习与集成门槛。

2\. **Enterprise Readiness（企业就绪）**

从协议层原生支持认证、授权、审计、追踪等企业级需求。

3\. **Asynchronous First（异步优先）**

支持长时间运行任务、断连恢复、人类介入等现实场景。

4\. **Modality Agnostic（模态无关）**

不仅支持文本，还支持文件、结构化表单、富媒体等多模态数据交换。

5\. **Opaque Execution（黑盒执行）**

Agent 无需暴露内部状态或工具链，仅通过声明能力（Agent Card）和上下文交换实现协作。

\## 核心概念与组件

\### 1. **Agent Card（代理卡片）**

\- 是 Agent 的“能力名片”，用于\*\*服务发现\*\*。

\- 包含：名称、描述、支持的技能（Skills）、输入/输出格式、认证方式等元数据 。

\- 其他 Agent 可通过 Agent Card 判断是否能协作，无需了解其实现细节。

\### 2. **Task（任务）**

\- 是 A2A 中\*\*有状态的工作单元\*\*，具有唯一 ID 和明确定义的生命周期 。

\- 状态机包括`submitted` → `working` → `completed` / `failed` / `cancelled` 等 。

\- 支持多轮交互、长时间运行、进度追踪，是异步协作的基础抽象 。

\### 3. **Message / Part / Artifact**

\- **Message**：Agent 间通信的基本单位。

\- **Part**：Message 的组成部分，可包含文本、文件引用、结构化数据等。

\- **Artifact**：任务执行过程中产生的可持久化输出（如生成的报告、图像等）。

\## 通信架构与技术栈

A2A 采用分层设计，明确分离\*\*传输层\*\*与\*\*协议语义层\*\*：

| 层级 | 技术选型 | 说明 |

|------|--------|------|

| **传输层** | HTTP/HTTPS | 必须支持 TLS 加密，确保安全 |

| **消息格式** | JSON-RPC 2.0 | 所有请求/响应负载均采用此标准格式 |

| **流式通信** | Server-Sent Events (SSE) | 用于异步推送任务状态、中间结果等 |

\> 例如：一个 `sendMessage` 请求通过 HTTPS 发送 JSON-RPC 调用，响应可能是一个 SSE 流，其中每个 `data` 字段包含一个 JSON-RPC 响应 。

这种设计使得 A2A **兼容现有 Web 基础设施**，易于部署、监控和调试。

\-–

\## 安全与企业级支持

\- **认证与授权**：基于标准 Web 实践（如 OAuth2、API Key），在 HTTP 层处理 。

\- **隐私与合规**：通过最小化上下文共享、不强制内存/工具暴露，降低数据泄露风险。

\- **可观测性**：任务 ID 与状态机天然支持追踪、日志、审计 。

\## 生态价值与未来展望

采用 A2A 协议可带来显著优势 ：

\- **提升互操作性**：不同框架（LangChain、LlamaIndex、AutoGen 等）开发的 Agent 可无缝协作。

\- **降低集成复杂度**：告别点对点定制集成，转向“即插即用”。

\- **激发创新**：鼓励开发者专注构建垂直领域 Agent（如法律、医疗、金融），形成繁荣生态。

\- **面向未来**：协议设计具备扩展性，可适应多模态、具身智能等新范式。

\-–

**总结**：A2A 协议不仅是技术规范，更是一种\*\*协作范式\*\*的升级。它为 AI 代理从“单打独斗”走向“群体智能”提供了基础设施，有望成为下一代 AI 应用的“TCP/IP”。对于开发者而言，掌握 A2A 意味着站在 AI 协作生态的前沿。
<!-- DAILY_CHECKIN_2025-10-18_END -->

# 2025-10-17
<!-- DAILY_CHECKIN_2025-10-17_START -->

## 为什么需要设计三层注册：  
  
1\. 身份层（Identity Registry）——“我是谁？”

**目的：确立唯一、可验证的智能体身份。**

-   每个 Agent 必须在链上注册，获得唯一的 `AgentID`。
    
-   该 ID 与其域名（AgentDomain）和以太坊地址（AgentAddress）绑定。
    
-   所有注册信息公开透明，任何人都能解析并验证。
    
-   链下，智能体需要在 `/.well-known/agent-card.json` 处发布自己的「Agent Card」，描述能力、模型类型、验证方式等。
    

**意义**：  
身份层解决了最基础的「谁是谁」的问题——没有可信身份，后续的信誉与验证都无从谈起。它构建了去中心化的「身份命名系统」，类似于区块链世界的 DNS。

* * *

### 2\. 信誉层（Reputation Registry）——“我值不值得信任？”

**目的：建立可追踪的声誉系统。**

-   当客户端智能体（Client Agent）与服务端智能体（Server Agent）交互后，可以授权反馈。
    
-   合约不存储评分，而是仅生成一个「反馈授权事件（AuthFeedback）」。
    
-   真正的评分与评价数据存放在链下（例如 JSON 文件），可以由第三方信誉系统读取并计算综合分数。
    

**意义**：  
信誉层为智能体提供了社会性信任来源。它模拟人类社会中的“口碑”，为低风险、日常任务（如内容生成、信息查询）提供足够的信任基础，而不需要昂贵的链上验证。

* * *

### 3\. 验证层（Validation Registry）——“我能证明我做对了吗？”

**目的：在高风险场景下提供强验证。**

-   用于发起和记录验证请求（ValidationRequest / Response）。
    
-   支持两种验证模式：
    
    -   **加密经济验证（Crypto-Economic Validation）**：验证者（Validator）需质押一定资金，若验证错误将被惩罚（slashing）。
        
    -   **密码学验证（Cryptographic Validation）**：通过 TEE 可信执行环境、ZK 证明等方式提供可验证的执行结果。
        
-   适用于金融交易、智能合约审计、医疗或高价值任务等高风险场景。
    

**意义**：  
验证层是“硬信任”机制，用经济或密码学手段保证行为真实可靠。它防止恶意或错误的智能体执行关键任务。

* * *

### 为什么要“三层”？

因为不同任务的风险与成本不同，信任机制需要「分层而非统一」：

| 场景 | 所需信任强度 | 对应层级 | 示例 |
| --- | --- | --- | --- |
| 低风险（如生成文本） | 弱信任 | 信誉层 | “内容好不好”由反馈决定 |
| 中风险（如金融建模） | 中等信任 | 经济验证层 | 验证者重跑计算、质押保证 |
| 高风险（如医疗决策） | 强信任 | 密码学验证层 | 通过 TEE 或 ZK 证明执行正确性 |

**总的目标**：在「成本」与「信任」之间取得最优平衡。  
区块链不适合把一切都放在链上，ERC-8004 采用混合式架构：**只把最必要的信任锚点上链**，其余逻辑交给链下扩展系统处理。

* * *

> ERC-8004 的三层信任体系让 AI 智能体能在不同风险场景下自由选择信任级别，从“轻量级信誉”到“加密经济验证”，再到“硬件级密码证明”，既保持去中心化，又兼顾效率与安全。
<!-- DAILY_CHECKIN_2025-10-17_END -->

# 2025-10-15
<!-- DAILY_CHECKIN_2025-10-15_START -->


# **ERC-8004: Trustless Agents**

[https://eips.ethereum.org/EIPS/eip-8004](https://eips.ethereum.org/EIPS/eip-8004)

**背景：**  
ERC-8004 把“发现、口碑、验证”三件事标准化为三套轻量注册表，为开放的 agent 经济提供可组合的信任层，补上 MCP/A2A 没覆盖的“谁、能不能信、谁来背书”的空白。

### **为什么有用（给产品/架构的直观价值）**

-   **可组合**：评分/验证事件在链上可被任意合约消费，离链再做复杂聚合；适合做 agent 目录、排行、质检与保险等上层生态。
    
-   **跨协议桥接**：注册文件里统一挂 **A2A、MCP、ENS、DID、钱包** 等端点，让通信层（会话/指令）与信任层（发现/评价/验证）解耦。
    
-   **成本/灵活度**：把大对象放离链（IPFS/HTTP）+ 链上存最小必要索引/哈希，既省 gas 又保留审计轨迹。围绕“哪些字段需要链上可读”社区仍在讨论中。
    

### **核心机制**

-   **Identity Registry（身份）**：把每个 agent 铸造成一枚 **ERC-721**（带 URIStorage），tokenURI 指向注册文件（含名称、说明、端点清单如 A2A/MCP/ENS/DID、agent 钱包等）。可多链/多注册，天然可浏览与转移。
    
-   **Reputation Registry（声誉）**：任何客户端地址（人/agent）都可在 agent 许可下提交 **0–100 分**的反馈，含可选标签与离链 JSON（IPFS 优先，链上存摘要/索引以便组合）。读接口支持按 reviewer/标签聚合。撤回与附加回应也有事件。
    
-   **Validation Registry（验证）**：agent 主动向某个 **validator 合约**发起验证请求（请求数据放离链 + 哈希承诺），validator 回写 **0–100** 的响应值与证据 URI（可多次更新，支持软/硬终局）。聚合读取接口可按 validator/tag 汇总。
    

> 提案刻意把**支付**排除在标准之外，但示例建议把 x402 支付证明等作为离链反馈字段一并记录。

### **最小落地路径**

1.  **部署 IdentityRegistry**（每链单例）→ register() 铸出 agentId → 设置 tokenURI 指向注册 JSON，填上 A2A/MCP/钱包等端点与 supportedTrust。
    
2.  **接单时**，agent 用 **EIP-191/ ERC-1271** 签出 feedbackAuth，授权某客户端地址可写反馈。客户端调用 giveFeedback(...) 上链；需要时可 revokeFeedback(...) 或附加 appendResponse(...)。查询用 getSummary(...) / readAllFeedback(...)。
    
3.  **需要强信任时**，调用 validationRequest(...) 指定 validator；待对方 validationResponse(...) 回写评分与证据。汇总用 getValidationStatus(...) / getSummary(...)。
<!-- DAILY_CHECKIN_2025-10-15_END -->
<!-- Content_END -->
