---
timezone: UTC+8
---

# sunen

**GitHub ID:** ssw123455

**Telegram:** @saa n

## Self-introduction

i am a student

## Notes
<!-- Content_START -->
# 2025-10-23
<!-- DAILY_CHECKIN_2025-10-23_START -->
Here's the English version of your note:

\### a2a Practice Learning Notes

\### 1.1. Key Goals of A2A\[¶\]([https://a2a-protocol.org/latest/specification/#11-key-goals-of-a2a](https://a2a-protocol.org/latest/specification/#11-key-goals-of-a2a) "Permanent link")

\- **Interoperability:** Bridge the communication gap between disparate agentic systems.

\- **Collaboration:** Enable agents to delegate tasks, exchange context, and work together on complex user requests.

\- **Discovery:** Allow agents to dynamically find and understand the capabilities of other agents.

\- **Flexibility:** Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.

\- **Security:** Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.

\- **Asynchronicity:** Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.

\> The A2A protocol acts as a messaging tier that lets these agents “talk” to each other despite their distinct \[\[agentic architectures\]\].

\### A Picture

!\[\[10.20\]\]

1\. Communication starts with a client agent sending a task to the \[\[chosen remote agent\]\]. Agent-to-agent communication occurs over HTTPS for secure transport, with JSON-RPC (Remote Procedure Call) 2.0 as the format for data exchange.

\- \[ \] how to choose agent?

2\. A2A also provides task management capabilities for complex tasks that cannot be completed immediately, such as those requiring human intervention or involving multiple steps. For long-running tasks that may take hours or days to complete, or when the client agent disconnects, the A2A protocol allows for asynchronous updates by sending push notifications to a secure client-provided webhook. For large or long outputs or continuous status updates, the A2A protocol supports real-time streaming using \[\[Server-Sent Events (SSE)\]\].

1\. wow how?

1\. The workflow is roughly like this: the client first submits a task, and the remote agent starts processing it. If the task is long or requires human intervention, it won't hold the connection indefinitely. Instead, it records the task and pushes updates in stages via the webhook you provide, such as "task accepted," "awaiting additional information," or "step 3 completed." When continuous, granular progress or large-volume results are needed, it switches to SSE, continuously sending event chunks over a persistent HTTP response, allowing you to receive fragmented text, file snippets, or status heartbeats like reading a data stream. This ensures you stay informed of progress and results without exposing internal implementations.

1\. \[ \] exactly code work

3\. A2A is still in its early stages, so organizations can expect improvements as the protocol matures. Among these improvements include the formal inclusion of authorization schemes and optional credentials in agent cards, a method for dynamically checking unanticipated or unsupported skills, support for dynamic \[\[user experience (UX)\]\] negotiation within tasks (such as adding audio or video in the middle of a conversation), and enhancing push notification methods and streaming reliability.

1\. This is the content of the \[\[Perception/Interaction Module\]\].

\### **FastA2A**

**FastA2A** is built on top of \[\[Starlette\]\], which means it's fully compatible with any ASGI server.

!\[\[Screenshot 2025-10-20 at 20.56.36.png\]\]

\`\`\`

from pydantic\_ai import Agent

agent = Agent('deepseek:chat', instructions='Be fun!')

app = [agent.to](http://agent.to)\_a2a()

##then

\`\`\`

\### A Very Good Use Case

\> \[!NOTE\]

\> MCP and A2A. Both protocols are meant to complement each other. For example, a retail store might have its own inventory agent that uses MCP to interact with \[\[databases\]\] storing information about products and stock levels. If the inventory agent detects products low in stock, it notifies an internal order agent, which then uses A2A to communicate with external supplier agents and place orders.

\### Regarding the code content of done\_a2a\_evaluation.ipynb

!\[\[Screenshot 2025-10-21 at 13.40.28.png\]\]

\### Example-1

`dong_a2a_quickstart.ipynb`

!\[\[CleanShot 2025-10-21 at 18.52.28@2x.png\]\]

\- Successfully created the agent and agent card, started the service on the server, and then used a client to call a simplified version of A2A – that's how it works!

\- However, there is no specific way for A2A communication here, only the framework. The communication methods, including discovery, are implemented in \[\[ISEK\]\].
<!-- DAILY_CHECKIN_2025-10-23_END -->

# 2025-10-22
<!-- DAILY_CHECKIN_2025-10-22_START -->

\## A2A Protocol Study Summary

The A2A (Agent-to-Agent) protocol aims to enable collaboration between autonomous agents, building a dynamic, multi-agent ecosystem to overcome data silos and application barriers.

\### Core Concepts and Roles

The A2A protocol involves the following core roles and concepts:

\* **Client**: Responsible for sending and receiving messages; can be another agent.

\* **Main Server**: Hosts agents, manages their "agent cards," and provides an HTTP host for message sending.

\* **Agent itself**: Handles core logic, such as managing request context, queuing status/event, and performing LLM/tool inference (e.g., via LangGraph).

\* **Agent Executor**: Acts as the core logic of the client, processing requests and generating responses/events. It is the core logic of how an A2A agent processes requests and generates responses/events.

\* **Agent ID**: Defined in the agent card based on the A2A foundation and can be registered with the \[\[Identity Registry\]\].

\* **Agent Card**: Defines an agent's capabilities and metadata.

\### Key Goals of A2A

The A2A protocol is committed to achieving the following goals:

\* **Interoperability**: Bridge the communication gap between disparate agentic systems.

\* **Collaboration**: Enable agents to delegate tasks, exchange context, and work together on complex user requests.

\* **Discovery**: Allow agents to dynamically find and understand the capabilities of other agents.

\* **Flexibility**: Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.

\* **Security**: Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.

\* **Asynchronicity**: Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.

\### Design Principles

The A2A protocol adheres to the following design principles:

\* **Embrace agentic capabilities**: Focuses on enabling agents to collaborate in their natural, unstructured modalities, even when they don’t share memory, tools, and context.

\* **Build on existing standards**: The protocol is built on top of existing, popular standards including HTTP, SSE, JSON-RPC, making it easier to integrate with existing IT stacks.

\* **Support for long-running tasks**: Designed to be flexible and support scenarios ranging from quick tasks to deep research that may take hours or even days (with human-in-the-loop), providing real-time feedback, notifications, and state updates throughout the process.

\### Design and Implementation Steps (Theory & Practice Combined)

1\. **Design Agent Functionality**: Clearly define what tasks the agent will perform and what services it will provide, including its core logic (LLM/tool inference), the tools it will use, and how it will handle request context and generate events.

2\. **Implement Functionality**: Implement the agent's logic and tools through coding.

3\. **Register with Server**: Register the agent with a server (e.g., IPFS or HTTP), which typically involves defining \[\[Agent Skills and Agent Cards\]\].

4\. **Client Operations**: Clients interact with agents using `send message` and `receive` operations.

5\. **Agent ID and Registration**: Agent IDs are defined in the agent card and registered with the \[\[Identity Registry\]\].

\### Communication Mechanisms

\* **Secure Transport**: Agent-to-agent communication occurs over HTTPS for secure transport.

\* **Data Exchange Format**: JSON-RPC 2.0 is used as the format for data exchange.

\* **Task Management**: For complex tasks that cannot be completed immediately (e.g., requiring human intervention or multiple steps), A2A provides task management features.

\* **Asynchronous Updates**: For long-running tasks, the A2A protocol allows for asynchronous updates via push notifications sent to secure webhooks provided by the client.

\* **Real-time Streaming**: For large or long outputs or continuous status updates, the A2A protocol supports real-time streaming using \[\[Server-Sent Events (SSE)\]\].

\### Practical Framework: FastA2A

\* **FastA2A** is built on top of \[Starlette\]([https://www.starlette.io/](https://www.starlette.io/)), meaning it's fully compatible with any ASGI server.

\* Example code demonstrates how to quickly convert an Agent into an A2A-compliant service using the `pydantic_ai` library:

\`\`\`python

from pydantic\_ai import Agent

agent = Agent('deepseek:chat', instructions='Be fun!')

app = [agent.to](http://agent.to)\_a2a()

\`\`\`

\### Benefits and Use Cases

\* **Maximize Agentic AI Benefits**: Enables agents to collaborate in dynamic, multi-agent ecosystems, bridging data silos and applications.

\* **Increase Autonomy and Productivity**: Allows agents to work together even if built by different vendors or frameworks, increasing autonomy and multiplying productivity gains while lowering long-term costs.

\* **Standardized Management**: Provides businesses with a standardized method for managing their agents across diverse platforms and cloud environments.

\* **Universal Interoperability**: Essential for fully realizing the potential of collaborative AI agents.

**Use Case Example**:

A retail store might have its own inventory agent that uses MCP to interact with databases storing information about products and stock levels. If the inventory agent detects products low in stock, it notifies an internal order agent, which then uses A2A to communicate with external supplier agents and place orders. This demonstrates how A2A can complement other protocols like \[\[MCP\]\] to achieve cross-system collaboration.

\### Future Developments

The A2A protocol is still in its early stages, and future improvements include:

\* Formal inclusion of authorization schemes and optional credentials in agent cards.

\* A method for dynamically checking unanticipated or unsupported skills.

\* Support for dynamic \[user experience (UX)\]([https://www.ibm.com/think/topics/user-experience](https://www.ibm.com/think/topics/user-experience)) negotiation within tasks (such as adding audio or video in the middle of a conversation).
<!-- DAILY_CHECKIN_2025-10-22_END -->

# 2025-10-21
<!-- DAILY_CHECKIN_2025-10-21_START -->


\### Expanding My Understanding

As I dive deeper into ERC-8004, my understanding is really expanding, and here's what I've learned and reflected upon:

**Diving into 'Quil' and Trust Models**

I've been looking into the 'quil' concept more deeply, and it really clarifies the problems ERC-8004 aims to solve. For instance, the scenario with Alice, an AI auditing agent, and Bob, a DeFi agent, perfectly illustrates the "trust gap." Alice can't verify Bob's legitimacy, and Bob can't assess Alice's reputation without prior interaction. This highlights key market failures: how do agents _discover_ reliable service providers, how do clients ensure _quality_, how do agents build _portable reputation_ across platforms, and how does _validation scale_ for different risk levels?

I also learned about the tiered trust models that address these issues:

_For_ \*low-stakes\*\* tasks (like content creation), a **reputation-based** system, drawing on accumulated client feedback, provides sufficient assurance. It's like a distributed review system.

_For_ \*medium-stakes\*\* tasks (like financial transactions), **cryptoeconomic validation** is used. Validators stake economic value that can be slashed if they act dishonestly, creating strong incentives for honest behavior.

_For_ \*high-stakes\*\* applications, **cryptographic validation** through TEE (Trusted Execution Environment) attestations offers cryptographic guarantees. TEEs ensure code executes as expected, private data remains confidential, and third parties can verify the execution environment's authenticity, making off-chain computations trustworthy.

**Understanding Layer 2 Scaling with Linea**

I also noted [Linea.build](http://Linea.build), which is an Ethereum Layer 2 scaling solution. It bundles transactions off-chain and uses zkEVM proofs to submit them to the Ethereum mainnet. This means lower fees and faster settlements, all while remaining compatible with Ethereum's toolchain. I understand that I still rely on Ethereum's security, but gain higher throughput and a better user experience on Layer 2.

**Reflecting on A2A's Origins and ERC-8004's Philosophy**

Interestingly, I found that Google's A2A protocol, while powerful, initially "assumes usage within organizations." This means discovery and trust assumptions for interactions _outside_ known organizational boundaries were largely overlooked. This is exactly where ERC-8004 comes in.

What I really appreciate about ERC-8004's development philosophy is its commitment to "not reinventing the wheel." It expands upon existing A2A concepts and integrates trust assumptions from other cutting-edge projects. For stake-secured validation, it draws inspiration from EigenLayer. For TEE attestations, it looks to projects like Phala and [Near.AI](http://Near.AI). This approach feels very pragmatic and leverages the best of the current Web3 landscape.

The "stay minimal" principle also resonates with me. Managing identity and trust is incredibly complex, and I believe there will be entire industries built around these challenges. So, the idea of a lightweight protocol that uses blockchains primarily as a logically centralized entry point for visibility (like seeing which agents are registered or which validation requests exist) and for data commitments makes a lot of sense. Everything else, like specific reputation calculation rules or trust thresholds, is intentionally left to the broader ecosystem to innovate upon. This is smart because it essentially solves the coordination problem by giving everyone equal data and visibility to create an agent economy, without being overly prescriptive.

I saw that the first draft reference implementation is already out, which is exciting to see the theory put into practice.

**My Personal Takeaway: The Web3-AI Convergence**

My biggest takeaway from all this is the immense "latent demand" within our ecosystem to apply Web3 principles to AI – truly the transformational technology of our era. I believe we all want permissionless, decentralized, censorship-resistant, and privacy-preserving AI. And crucially, we need a common language for both humans and agents to make this a reality. For me, this is the way Web3 and AI finally combine, and it's something I deeply believe in.

I've also bookmarked "mass survive technical" on Medium for later reading, as it seems relevant to these broader themes.

I've been reflecting on how platform monopolies create stagnant markets and misdirect value. Decentralization feels inevitable. My next personal step is to fully grasp the technical principles, build a system for my graduation project, and then focus on the commercialization aspect of market deployment.

\---
<!-- DAILY_CHECKIN_2025-10-21_END -->

# 2025-10-20
<!-- DAILY_CHECKIN_2025-10-20_START -->



\## ERC-8004: Building a Trust Layer for Autonomous Agents in Web3

This note outlines the core principles, technical architecture, and significant advantages of ERC-8004, a protocol designed to establish a trust layer for autonomous agents within the Web3 ecosystem. It addresses the critical need for verifiable identity, reputation, and validation in agent-to-agent (A2A) and multi-agent communication protocols (MCP), thereby enabling a more robust, private, and integrated agent economy.

\### 1. Bridging the Trust Gap in Agent Communication

The fundamental challenge ERC-8004 tackles is the "trust gap" in agent communication, particularly when interactions occur between unknown parties. While existing protocols like A2A and MCP utilize JWTs (JSON Web Tokens) for enterprise-grade transport security and access control within established organizations, they fall short when trust needs to be extended beyond pre-existing relationships.

ERC-8004 steps in by anchoring agent identities, authorizing feedback, and recording validation hooks on the blockchain. This enables:

\* **Continuous System Enhancement**: Linking the results of A2A/MCP executions to the system continuously strengthens its usability, while maintaining privacy and integration.

\* **Extended Trust**: JWTs secure session-level interactions, but ERC-8004's on-chain registration layer (Reputation and Validation Registries) provides a foundational trust mechanism for identity, reputation, and verification across unknown entities.

\* **Complete Task Lifecycle Orchestration**: The protocol enables a full lifecycle from agent discovery and negotiation to execution, verification, and reputation building.

\* **Scalability for Complex Work**: The more capable and complex the tasks, the more effectively this system can orchestrate and secure the work.

\### 2. The Core Trust Infrastructure: Three Interconnected Smart Contracts

ERC-8004's technical implementation revolves around three mutually reinforcing smart contracts, forming a robust trust infrastructure on the blockchain:

\* **Identity Registry**:

\* A minimal on-chain handle based on ERC-721 with the URIStorage extension.

\* It provides every agent with a portable, censorship-resistant identifier.

\* The `tokenURI` resolves to an agent's off-chain registration file (e.g., on IPFS), describing its capabilities and endpoints. Agents can be discovered through this URL.

\* **Reputation Registry**:

\* A standard interface for posting and fetching feedback signals.

\* It allows clients (human or agent) to `giveFeedback` to registered agents, typically after the agent has signed a `feedbackAuth` to authorize this.

\* Scoring and aggregation occur both on-chain (for composability with other smart contracts) and off-chain (for more sophisticated algorithms).

\* Feedback details (score, tags, file URI, file hash) are recorded on-chain via `NewFeedback` events, enabling an ecosystem of specialized services for agent scoring, auditor networks, and insurance pools.

\* **Validation Registry**:

\* Provides generic hooks for requesting and recording independent validator checks.

\* Agents or their operators can submit a `validationRequest` with a `requestUri` (pointing to off-chain data like inputs, outputs, logs) and an optional `requestHash` (for data commitment).

\* Designated validator smart contracts receive these requests and run their validation logic (e.g., stake-secured re-execution, zkML verification, TEE attestations, or trusted judge rules).

\* Validators then submit a `validationResponse` with a score (0-100) and optional evidence links. This process is decoupled from the agent's call, allowing for post-hoc checks, pre-delivery inspections, dispute resolution, or periodic audits.

\### 3. Key Advantages and Advanced Features

ERC-8004 introduces several powerful features that enhance the agent economy:

\* **On-chain Discoverability**: MCP and A2A execution results, along with agent capabilities, can be stored on-chain, making them widely discoverable.

\* **Cross-Chain Operations**: An agent registered and receiving feedback on one chain (e.g., Chain A) can still operate and transact on other chains, fostering a truly interoperable agent network. Agents can also register on multiple chains if desired.

\* **Flexible Agent Communication Protocols**: The protocol links from the blockchain to a flexible registration file, allowing for the inclusion of various endpoints and combining AI primitives (MCP, A2A) with Web3 primitives (wallet addresses, DIDs, and ENS names).

\* **Flexible Feedback Structure**: It leverages established nomenclature from A2A (tasks, skills) and MCP (tools, prompts) while offering complete flexibility in the structure of feedback signals.

\* **Gas Sponsorship**: By decoupling client registration, any application can implement frictionless feedback using EIP-7702, potentially sponsoring gas fees for users.

\* **Enhanced Indexing**: With feedback data saved on-chain and full data stored on IPFS, subgraphs can easily be leveraged to create indexers, significantly improving user experience (UX).

\* **Deployment Model**: Registries are expected to be deployed as singletons per chain, simplifying management and access.

\### Conclusion: The Convergence of Web3 and AI

ERC-8004 represents a pivotal step in applying core Web3 principles—permissionless, decentralization, censorship-resistance, and privacy-preservation—to the transformative field of AI. By providing a common, blockchain-anchored language and trust layer for humans and agents, it aims to solve the coordination problem in an emerging agent economy. This minimal yet powerful protocol enables visibility and data commitments on-chain, while leaving specific reputation calculation rules and trust thresholds to the broader ecosystem, fostering innovation and a truly autonomous, trusted agentic web.
<!-- DAILY_CHECKIN_2025-10-20_END -->

# 2025-10-16
<!-- DAILY_CHECKIN_2025-10-16_START -->




completing the A2A Python SDK Tutorial! learned how to:

\- Set up environment for A2A development.

\- Define \[\[Agent Skills and Agent Cards\]\] using the SDK's types.

\- Implement a basic HelloWorld A2A server and client.

\- acilent is handle `send message`and `recei` ,a main is handl`agent card and http host for meesage been send` ,a agent is handle `**CurrencyAgent**, manages the **RequestContext**, and enqueues status/artifact events. The LangGraph agent itself handles the LLM/tool reasoning.`

\- Understand and implement streaming capabilities.

\- Integrate a more complex agent using LangGraph, demonstrating task state management and tool use.
<!-- DAILY_CHECKIN_2025-10-16_END -->

# 2025-10-15
<!-- DAILY_CHECKIN_2025-10-15_START -->





overlook a aquick introduce:

ERC‑8004 makes “autonomous negotiation, execution, and reputation-building” possible by adding a thin, blockchain‑anchored trust layer to the existing agent‑to‑agent protocol. Agents first register a portable identifier in the **Identity Registry**, which resolves to an off‑chain AgentCard describing capabilities and endpoints. Before or after a task, the server agent authorizes feedback via the **Reputation Registry**; the feedback itself stays off‑chain but is cryptographically linked to an on‑chain event, letting agents accumulate portable reputation across organizations. For higher‑stakes work, the **Validation Registry** lets third‑party validators re‑run computations, stake economic value that can be slashed, or provide TEE attestations—giving cryptographic or economic guarantees of correctness. Together, these three registries let unknown agents discover each other, negotiate work, verify outcomes, and persist reputation without any prior trust relationship.
<!-- DAILY_CHECKIN_2025-10-15_END -->
<!-- Content_END -->
